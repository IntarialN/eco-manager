# Чат и обратный звонок

Фича покрывает требование клиента №7: «Есть возможность общения через чат‑бот или заказать обратный звонок». На сайте появляется кнопка связи, диалог ведётся в веб-чате, а операторы (админы, модераторы) отвечают из Telegram. Все действия записываются в общую БД проекта.

## 1. Цели
- Дать клиенту мгновенный канал связи без выхода из личного кабинета.
- Обеспечить операторам единое рабочее место (Telegram-бот с авторизацией по единой БД).
- Логировать историю обращений и обратных звонков для контроля SLA.
- Минимизировать зависимость от сторонних SaaS (самостоятельный чат + легкий Telegram-бот).

## 2. Участники и сценарии

| Роль | Сценарий | Точки входа |
|------|----------|-------------|
| Клиент | Открывает виджет, пишет сообщение, оставляет контакт для звонка. | Кнопка «Связаться» в шапке / в футере / из блока поддержки. |
| Потенциальный клиент (неавторизован) | Заполняет форму обратного звонка, получает ответ по email/телефону. | Публичная версия / лендинг. |
| Админ | Принимает сообщения в Telegram, отвечает, эскалирует, назначает ответственного менеджера. | Telegram-бот + админка (история). |
| Модератор | Отвечает в Telegram, видит только назначенных клиентов. | Telegram-бот. |
| Менеджер | Просматривает историю в админке, фиксирует результат звонка. | Back-office UI. |

## 3. Модель данных (через единый PostgreSQL)
- `chat_session`
  - `id`, `client_id` (nullable для гостя), `external_contact` (email/phone), `source` (web, telegram, callback)
  - `status`: `open`, `pending_callback`, `closed`
  - `initiator`: `client`, `operator`
  - `created_at`, `closed_at`, `assigned_user_id`
- `chat_message`
  - `id`, `session_id`, `sender_type` (`client`, `operator`, `system`), `sender_id` (nullable)
  - `body`, `attachments` (JSON), `delivered_at`, `read_at`
  - `direction` (web_to_bot, bot_to_web)
- `callback_request`
  - `id`, `session_id`, `phone`, `preferred_time`, `status`
- `user_telegram_identity`
  - `user_id`, `telegram_user_id`, `telegram_username`, `confirmed_at`

Схемы миграций добавляем в `yii-app/migrations` после финализации требований.

## 4. Backend/API
1. **Web API** (`chat-service` за `api-gateway`):
   - `POST /chat/sessions` — создать сессию, валидация reCAPTCHA для гостей.
   - `POST /chat/messages` — отправить сообщение (websocket + REST fallback).
   - `POST /chat/callback` — инициировать обратный звонок.
   - `GET /chat/sessions/{id}` — опрос прогресса (long polling / SSE).
2. **Internal events**:
   - `chat.session.created`, `chat.message.sent`, `chat.callback.requested` → в RabbitMQ для нотификаций.
3. **Notification hooks**:
   - NotificationService ловит `chat.callback.requested` и шлёт письмо ответственному, дублирует в Telegram.

## 5. Telegram-бот
- Разворачиваем отдельный сервис `support-bot` (Node.js или Python aiogram) в docker-compose.
- Авторизация:
  - Пользователь пишет `/login <token>`.
  - `token` создаётся в админке (JWT с user_id), проверяется через API `auth-service`.
  - После привязки `user_telegram_identity` оператор получает уведомления только по назначенным клиентам.
- Сообщения:
  - Веб → очередь → бот → оператор.
  - Оператор отвечает в Telegram → бот дергает `chat-service` `POST /chat/messages` (sender_type `operator`).
- Команды:
  - `/open <client_id>` — подписаться на сессию.
  - `/close <session_id>` — закрыть сессию (фиксирует SLA).
  - `/callback <session_id>` — пометить как «ждёт звонка».

## 6. UI/UX
- Виджет в шапке (desktop) и плавающая кнопка (mobile). При клике открывается панель поверх контента.
- Страница укладывается в 100vh: шапка сверху, основной блок с формой по центру, футер снизу (соответствует недавнему требованию по макету). Виджет не ломает сетку.
- Обязательные поля для гостей: имя, email/телефон. Авторизованный клиент подставляет данные из профиля.
- Индикаторы статуса: «Оператор подключается», «Ответ получен», «Ожидайте звонка».
- Валидация логина/сообщения — на русском (используем `Yii::t`). Латиница, цифры, символы `._-` для логина; русские буквы запрещены (см. багрепорт «логин на русском»).
- Виджет отображает историю сообщений (polling 5 сек), хранит sessionId в `localStorage` и поддерживает продолжение диалога после перезагрузки.
- Кнопка «Написать нам» доступна только после авторизации клиентом; в свернутом виде она занимает минимум места, а при клике плавно раскрывает панель. Операторы кнопку не видят.
- При закрытом виджете новые сообщения подсвечивают подсказку над кнопкой и badge «Чаты» в шапке; обновление работает через регулярный polling (`GET /chat/<id>?since_id=...`) каждые ~5 секунд. Планируема миграция на Centrifugo/WebSocket (см. `docs/architecture/chat-realtime.md`).
- Mickро-MVP реализован: плавающая кнопка + панель в `yii-app/views/layouts/main.php` отправляет запросы на `POST /chat/session`, `POST /chat/{id}/message`, при заполненном телефоне — `POST /chat/{id}/callback`; история берётся из `GET /chat/{id}`.
- Автоархивация: если нет сообщений >30 минут, cron-задача `php yii chat-maintenance/archive` переводит сессию в `closed`. При новом сообщении статус снова `open`, история сохраняется. Входящие от клиента снимают закрепление оператора, возвращая чат в очередь «Открытые».

### UI модераторов
- Страница `/chat/inbox` показывает список сессий, источник, статус и назначенного оператора (требуется роль admin/manager).
- `/chat/thread/<id>` отображает всю переписку и позволяет взять чат в работу (`POST /chat/<id>/assign`) и ответить (`POST /chat/<id>/reply`); ответы сохраняются в истории и видны клиенту.
- Навигационный пункт «Чаты» подсвечивается при появлении новых диалогов/сообщений (плюс счётчик необработанных).
- Админ-страница разбита на вкладки «Мои», «Открытые», «Закрытые» с индикаторами непрочитанных и возможностью фильтрации.

## 7. Безопасность и соответствие РФ
- Хранение персональных данных в РФ (текущий кластер PostgreSQL).
- Логирование согласий на обработку персональных данных в `callback_request`.
- Шифрование трафика (HTTPS/MTProto). Телеграм-бот официально работает через HTTPS webhook.
- Проверка операторов (admins/moderators) через RBAC (см. `docs/admin/roles-and-permissions.md`).

## 8. Мониторинг и SLA
- Метрики: среднее время первого ответа, закрытия, количество незакрытых сессий.
- Логи Telegram-бота + alert, если webhook недоступен >1 мин.
- Тестовые сценарии в `tests/unit/chat` + smoke-тест через `support-bot` sandbox.

## 9. План внедрения (итерации)
1. **Документация и схемы** (текущий этап).
2. **Бэкенд-скелет**: миграции, REST API, сервис-слой, unit-тесты.
3. **Telegram-бот + docker-compose сервис**.
4. **Веб-виджет и интеграция в layout (<=100vh)**.
5. **SLA и мониторинг**.
6. **Аналитика и completed-лог**.

## 10. Инструкции для ИИ/разработчиков
- Перед разработкой сверяйтесь с этим документом и `docs/assistant-guidelines.md`.
- Любое выполненное действие фиксируем в `docs/completed/` (один файл на день/фичу) + обновляем `docs/completed/README.md`.
- Все задачи по чату должны появиться в `docs/documentation-todo.md` с разбивкой по этапам.
- Ветки именуем `feature/chat-support-*`, коммиты — `feat: ... chat support`.
- Любые допущения (например, провайдер телефонии) документируем сразу, чтобы не потерять контекст между сессиями.

## 11. Открытые вопросы
- Провайдер обратного звонка (Asterisk? внешнее API?). Нужны требования от клиента.
- Конкретный стек для бота (Node.js vs Python) — определить исходя из команды.
- Требуется ли запись звонков? пока нет.
- Максимальное время ожидания оператора (минута/пять?) — уточнить.

## 12. Готовность
- [x] Описаны сценарии и роли.
- [x] Зафиксирована модель данных.
- [x] Определены API и интеграции между сервисами.
- [x] Намечен план внедрения.
- [ ] Договориться о провайдере обратного звонка и SLA.
